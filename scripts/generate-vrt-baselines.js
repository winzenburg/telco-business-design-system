#!/usr/bin/env node

/**
 * Visual Regression Testing Baseline Generator
 * 
 * Automatically discovers all Storybook stories and generates
 * visual regression test baselines for them.
 */

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const STORYBOOK_URL = process.env.STORYBOOK_URL || 'http://localhost:6006';
const OUTPUT_DIR = path.join(path.dirname(__dirname), 'tests', 'visual-regression');

class VRTBaselineGenerator {
  constructor() {
    this.stories = [];
    this.componentsProcessed = 0;
  }

  async generateBaselines() {
    console.log('üì∏ Generating Visual Regression Test Baselines...');
    console.log('====================================================\n');
    
    // Ensure Storybook is running
    await this.checkStorybookRunning();
    
    // Discover all stories
    await this.discoverStories();
    
    // Generate test files
    await this.generateTestFiles();
    
    // Run Playwright to generate baselines
    await this.runPlaywright();
    
    console.log('‚úÖ Visual regression test baselines generated successfully!');
    console.log(`\nüìä Summary:`);
    console.log(`   Stories discovered: ${this.stories.length}`);
    console.log(`   Components processed: ${this.componentsProcessed}`);
    console.log(`   Test files: ${OUTPUT_DIR}`);
  }

  async checkStorybookRunning() {
    try {
      const response = await fetch(STORYBOOK_URL);
      if (!response.ok) throw new Error('Storybook not accessible');
      console.log('‚úÖ Storybook is running at', STORYBOOK_URL);
    } catch (error) {
      console.error('‚ùå Error: Storybook is not running at', STORYBOOK_URL);
      console.error('   Please run "npm run dev" first\n');
      process.exit(1);
    }
  }

  async discoverStories() {
    console.log('üîç Discovering Storybook stories...');
    
    try {
      // Fetch the Storybook index
      const response = await fetch(`${STORYBOOK_URL}/index.json`);
      const index = await response.json();
      
      // Extract story information
      this.stories = Object.values(index.entries || {})
        .filter(entry => entry.type === 'story')
        .map(story => ({
          id: story.id,
          title: story.title,
          name: story.name,
          component: story.title.split('/').pop(),
          category: story.title.includes('/') ? story.title.split('/')[0] : 'Components'
        }));
      
      console.log(`   Found ${this.stories.length} stories`);
      
      // Group by component
      const componentGroups = this.stories.reduce((acc, story) => {
        const component = story.component;
        if (!acc[component]) acc[component] = [];
        acc[component].push(story);
        return acc;
      }, {});
      
      this.componentsProcessed = Object.keys(componentGroups).length;
      console.log(`   Across ${this.componentsProcessed} components\n`);
      
    } catch (error) {
      console.error('‚ùå Error discovering stories:', error.message);
      process.exit(1);
    }
  }

  async generateTestFiles() {
    console.log('üìù Generating optimized test files...');
    
    // Ensure output directory exists
    if (!fs.existsSync(OUTPUT_DIR)) {
      fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }
    
    // Group stories by component for efficient testing
    const componentGroups = this.stories.reduce((acc, story) => {
      const component = story.component;
      if (!acc[component]) acc[component] = [];
      acc[component].push(story);
      return acc;
    }, {});
    
    // Generate a test file for each component
    for (const [component, stories] of Object.entries(componentGroups)) {
      const testContent = this.generateComponentTestFile(component, stories);
      const testPath = path.join(OUTPUT_DIR, `${component.toLowerCase()}.spec.ts`);
      fs.writeFileSync(testPath, testContent);
      console.log(`   Generated: ${component.toLowerCase()}.spec.ts`);
    }
    
    console.log(`\n   Total test files: ${Object.keys(componentGroups).length}\n`);
  }

  generateComponentTestFile(component, stories) {
    return `/**
 * Visual Regression Tests for ${component}
 * Auto-generated by generate-vrt-baselines.js
 */

import { test, expect } from '@playwright/test';

const STORYBOOK_URL = '${STORYBOOK_URL}';

async function navigateToStory(page: any, storyId: string, theme = 'light') {
  const url = \`\${STORYBOOK_URL}/iframe.html?id=\${storyId}&viewMode=story&theme=\${theme}\`;
  await page.goto(url);
  await page.waitForLoadState('networkidle');
  await page.waitForTimeout(500); // Allow animations to settle
}

async function stabilizeVisuals(page: any) {
  // Disable animations and hide variable content
  await page.addStyleTag({
    content: \`
      *, *::before, *::after {
        animation-duration: 0s !important;
        transition-duration: 0s !important;
      }
      .loading, .spinner, [data-testid*="loading"] {
        visibility: hidden !important;
      }
    \`
  });
}

test.describe('${component} Visual Tests', () => {
  ${stories.map(story => `
  test('${story.name} - light theme', async ({ page }) => {
    await navigateToStory(page, '${story.id}', 'light');
    await stabilizeVisuals(page);
    
    await expect(page.locator('#storybook-root')).toHaveScreenshot(
      '${story.id}-light.png',
      {
        threshold: 0.2,
        animations: 'disabled'
      }
    );
  });
  
  test('${story.name} - dark theme', async ({ page }) => {
    await navigateToStory(page, '${story.id}', 'dark');
    await stabilizeVisuals(page);
    
    await expect(page.locator('#storybook-root')).toHaveScreenshot(
      '${story.id}-dark.png',
      {
        threshold: 0.2,
        animations: 'disabled'
      }
    );
  });`).join('')}
});

// Interactive state tests for key components
${this.shouldGenerateInteractiveTests(component) ? this.generateInteractiveTests(component, stories[0]) : ''}
`;
  }

  shouldGenerateInteractiveTests(component) {
    const interactiveComponents = ['Button', 'Input', 'Select', 'Checkbox', 'Radio', 'Switch'];
    return interactiveComponents.includes(component);
  }

  generateInteractiveTests(component, firstStory) {
    return `
test.describe('${component} Interactive States', () => {
  test('hover state', async ({ page }) => {
    await navigateToStory(page, '${firstStory.id}');
    await stabilizeVisuals(page);
    
    const element = page.locator('${component.toLowerCase()}').first();
    await element.hover();
    await page.waitForTimeout(100);
    
    await expect(page.locator('#storybook-root')).toHaveScreenshot(
      '${firstStory.id}-hover.png',
      { threshold: 0.2, animations: 'disabled' }
    );
  });
  
  test('focus state', async ({ page }) => {
    await navigateToStory(page, '${firstStory.id}');
    await stabilizeVisuals(page);
    
    const element = page.locator('${component.toLowerCase()}').first();
    await element.focus();
    await page.waitForTimeout(100);
    
    await expect(page.locator('#storybook-root')).toHaveScreenshot(
      '${firstStory.id}-focus.png',
      { threshold: 0.2, animations: 'disabled' }
    );
  });
});`;
  }

  async runPlaywright() {
    console.log('üé≠ Running Playwright to generate baseline screenshots...');
    
    try {
      // Run Playwright with update snapshots flag
      const command = 'npx playwright test tests/visual-regression --update-snapshots --reporter=list';
      console.log(`   Command: ${command}\n`);
      
      execSync(command, { 
        stdio: 'inherit',
        cwd: path.dirname(__dirname)
      });
      
    } catch (error) {
      console.error('‚ùå Error running Playwright tests:', error.message);
      console.error('\n   Make sure Playwright is installed: npx playwright install');
      process.exit(1);
    }
  }
}

// Run the generator if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const generator = new VRTBaselineGenerator();
  generator.generateBaselines().catch(error => {
    console.error('\n‚ùå Fatal error:', error);
    process.exit(1);
  });
}